## user.py - Class Definition for ActiveUser, the main class that handles user profiles and interactions
## Author  - Vincent Fiestada

## Import built-in time module for age and bday handling

from time import localtime
from friendship import *
from conversation import *
from notification import *
from status import *

class ActiveUser:
	## Keeps track of all used usernames to prevent duplication:
	usedNames = []
	## Keeps track of logged in / active users' IDs:
	activeUsers = []
	
	## username and password are required parameters;
	## bday(optional) must be passed as a dictionary 
	## with items year, month, and day
	## gender should be either 'M' or 'F', or 'U' if unspecified
	def __init__(self, uid, username, password, gender = None, bday = None, jobs = [], edu = [], notifs = []):
		self.userID = uid
		if username not in ActiveUser.usedNames:
			self.username = username
		else:
			self.username = "User" + str(self.userID)
		## Add username to list of used usernames:
		ActiveUser.usedNames.append(self.username)
		self.password = password
		self.profilePicfilename = None ## to be generated later
		self.friends = list() ## a list of Friendship objects
		self.conversations = list() ## a list of Conversation objects
		self.notifications = list() ## a list of Notification objects
		for n in notifs:
			self.notifications.append(Notification(n))
		self.statuses = list() ## a list of Status objects
		self.newsfeed = NewsFeed(list()) ## a newsfeed object that must be generated by a ControlCenter
		self.gender = gender
		self.age = None
		self.bday = bday
		self.jobHistory = jobs
		self.educationHistory = edu
		self.timeLineSelectedFriend = self.userID
		self.timeLineSelectedIndex = 0
	
	def getUserID(self):
		return self.userID

	def getUsername(self):
		return self.username

	def setUsername(self, newusername):
		if newusername in ActiveUser.usedNames:
			return "Username already in use."
		ActiveUser.usedNames.remove(self.username)
		self.username = newusername
		ActiveUser.usedNames.append(newusername)
		return "SUCCESS"

	def getPassword(self):
		return self.password

	def setPassword(self, newpass):
		self.password = newpass

	def getProfilePic(self):
		if self.profilePicfilename != None:
			return self.profilePicfilename
		self.profilePicfilename = "users/" + self.username + "/profile.gif"
		return self.profilePicfilename

	def resetProfilePic(self):
		self.profilePicfilename = None

	def getGender(self):
		if self.gender == 'M':
			return "Male"
		elif self.gender == 'F':
			return "Female"
		else:
			return "Unspecified"

	## 'newgender' argument must be 'M' or 'F', other gender will be returned as "Unspecified" in future
	def setGender(self, newgender):
		self.gender = newgender

	def getAge(self):
		## BIG ASSUMPTION HERE!
		## Assumes that the program won't be running longer than a day. Because why would you?
		if self.age != None:
			return self.age
		if self.bday != None:
			currentDate = localtime()
			significantYears = self.bday['year']
			
			if self.bday['month'] > currentDate.tm_mon:
				## Adjust for bdays ahead of current month
				significantYears += 1
			elif self.bday['day'] > currentDate.tm_mday:
				## Adjust for bdays ahead of current month day
				significantYears += 1
			
			## Subtract bday year from current year
			self.age = currentDate.tm_year - significantYears
			return self.age
		else:
			return 0

	def getBday(self):
		if self.bday != None:
			months = ("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")
			return months[self.bday['month']-1] + " " + str(self.bday['day']) + ", " + str(self.bday['year'])
		else: 
			return "Unspecified"

	def getBdayDict(self):
		return self.bday

	def setBday(self, newbday):
		## newbday must be a dictionary with entries year, month, and day
		self.bday = newbday
		## because the bday is new, the age must be recomputed
		self.age = None

	def getJobHistory(self):
		return self.jobHistory

	def setJobHistory(self, joblist):
		self.jobHistory = joblist

	def getEducationHistory(self):
		return self.educationHistory

	def setEducationHistory(self, edulist):
		self.educationHistory = edulist

	def getFriends(self):
		return self.friends

	def addFriendship(self, friendship):
		self.friends.append(friendship)

	def setFriends(self, newfriendlist):
		self.friends = newfriendlist

	def unfriendById(self, uid):
		for f in self.friends:
			if f.getFriendID() == uid:
				self.friends.remove(f)
				break

	def getConversations(self):
		return self.conversations

	def addConversation(self, conversation):
		if conversation not in self.conversations:
			self.conversations.append(conversation)
			conversation.join(self.userID)

	def setConversations(self, newconversationslist):
		self.conversations = newconversationslist
	
	## 'conversationtoexit' argument must be a Conversation Object already in the list of conversations this user has
	def exitConversation(self, conversationtoexit):
		try:
			conversationtoexit.disjoin(self.userID)
			self.conversations.remove(conversationtoexit)
		except:
			return

	def getNotifications(self):
		return self.notifications
	
	def addNotification(self, text):
		self.notifications.append(Notification(text))

	def getNotificationByIndex(self, index):
		try:
			return self.notifications[index]
		except:
			return None

	def getStatuses(self):
		return self.statuses
	
	def getNewsfeed(self):
		return self.newsfeed

	## 'todelete' argument must be a Status object that is included in self.statuses
	def deleteStatusByValue(self, todelete):
		self.statuses.remove(todelete)
	
	# 'status' must be a Status Object
	def addStatus(self, status):
		self.statuses.insert(0, status)

	## 'newsfeed' must be a list of status objects
	def setNewsfeed(self, newsfeed):
		self.newsfeed.setStatuses(newsfeed)

	def setStatuses(self, statuslist):
		self.statuses = statuslist

	def logout(self):
		try:
			ActiveUser.activeUsers.remove(self.userID)
		except:
			return

	def gettimeLineSelectedFriend(self):
		return self.timeLineSelectedFriend
	
	def gettimeLineSelectedIndex(self):
		return self.timeLineSelectedIndex
	
	def settimeLineSelectedFriend(self, uid):
		self.timeLineSelectedFriend = uid
	
	def settimeLineSelectedIndex(self, index):
		self.timeLineSelectedIndex = index